"use client";

import { useEffect, useMemo, useState } from "react";
import { RoleCard } from "./components/RoleCard";
import { INITIAL_SLOTS } from "./constants";
import { useChampions } from "./hooks/useChampions";
import { useIsLandscape } from "./hooks/useIsLandscape";
import { useNow } from "./hooks/useNow";
import type { RoleId, RoleSlot } from "./types";

const DDRAGON_VERSION = "14.23.1";

type ChampionFetchState = {
  champions: ChampionSummary[];
  loading: boolean;
  error: string | null;
};

function useChampions(): ChampionFetchState {
  const [state, setState] = useState<ChampionFetchState>({
    champions: [],
    loading: true,
    error: null,
  });

  useEffect(() => {
    let cancelled = false;

    async function load() {
      try {
        const res = await fetch(
          `https://ddragon.leagueoflegends.com/cdn/${DDRAGON_VERSION}/data/en_US/championFull.json`
        );
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const json = await res.json();
        const data = json.data as Record<string, any>;

        const champions: ChampionSummary[] = Object.values(data).map(
          (champ: any) => {
            const ult =
              Array.isArray(champ.spells) && champ.spells.length > 3
                ? champ.spells[3]
                : null;

            const ultImageKey = ult?.image?.full ?? `${champ.id}R.png`;
            return {
              id: champ.id as string,
              name: champ.name as string,
              imageUrl: `https://ddragon.leagueoflegends.com/cdn/${DDRAGON_VERSION}/img/champion/${champ.id}.png`,
              ultName: ult?.name ?? "Ult",
              ultCooldowns: Array.isArray(ult?.cooldown)
                ? (ult.cooldown as number[])
                : [],
              ultImageUrl: `https://ddragon.leagueoflegends.com/cdn/${DDRAGON_VERSION}/img/spell/${ultImageKey}`,
              tags: Array.isArray(champ.tags) ? (champ.tags as string[]) : [],
            };
          }
        );

        champions.sort((a, b) => a.name.localeCompare(b.name));

        if (!cancelled) {
          setState({ champions, loading: false, error: null });
        }
      } catch (err) {
        if (!cancelled) {
          setState({
            champions: [],
            loading: false,
            error: "Erro ao carregar campeões",
          });
        }
      }
    }

    load();

    return () => {
      cancelled = true;
    };
  }, []);

  return state;
}

function useIsLandscape() {
  const [isLandscape, setIsLandscape] = useState(false);

  useEffect(() => {
    function update() {
      if (typeof window === "undefined") return;
      setIsLandscape(window.innerWidth > window.innerHeight);
    }

    update();
    window.addEventListener("resize", update);
    return () => window.removeEventListener("resize", update);
  }, []);

  return isLandscape;
}

function useNow(intervalMs: number) {
  const [now, setNow] = useState(() => Date.now());

  useEffect(() => {
    const id = setInterval(() => {
      setNow(Date.now());
    }, intervalMs);

    return () => clearInterval(id);
  }, [intervalMs]);

  return now;
}

type SpellButtonProps = {
  state: SpellState;
  size: "large" | "small";
  now: number;
  onToggle: () => void;
};

function SpellButton({ state, size, now, onToggle }: SpellButtonProps) {
  const spell = SPELLS[state.spellId];
  const baseSeconds = spell.cooldown;
  const [clickCount, setClickCount] = useState(0);
  const clickTimerRef = useState<NodeJS.Timeout | null>(null)[0];

  const remainingSeconds = useMemo(() => {
    if (!state.endTime) return 0;
    const diff = Math.ceil((state.endTime - now) / 1000);
    if (diff <= 0) return 0;
    return diff;
  }, [state.endTime, now]);

  const isOnCooldown = remainingSeconds > 0;

  const dimension = size === "large" ? "w-20 h-20" : "w-16 h-16";
  const textSize = size === "large" ? "text-xl" : "text-sm";

  const progress = isOnCooldown
    ? Math.min(1, Math.max(0, remainingSeconds / baseSeconds))
    : 0;

  const handleClick = () => {
    setClickCount((prev) => prev + 1);

    if (clickTimerRef) {
      clearTimeout(clickTimerRef);
    }

    const timer = setTimeout(() => {
      if (clickCount + 1 === 1) {
        // Single click
        if (!isOnCooldown) {
          onToggle();
        }
      } else if (clickCount + 1 >= 2) {
        // Double click
        if (isOnCooldown) {
          onToggle();
        }
      }
      setClickCount(0);
    }, 250);

    // @ts-ignore
    clickTimerRef = timer;
  };

  return (
    <button
      type="button"
      onClick={handleClick}
      className={`relative ${dimension} rounded-md border border-slate-600 bg-slate-900 text-slate-100 shadow-sm transition-transform active:scale-95 flex items-center justify-center overflow-hidden`}
    >
      <Image
        src={spell.iconSrc}
        alt={spell.name}
        fill
        sizes="80px"
        className="object-cover"
        priority={false}
      />
      <div
        className={`absolute inset-0 border-2 ${
          isOnCooldown ? "border-yellow-400/80" : "border-slate-500/40"
        } rounded-md`}
      />
      {isOnCooldown && (
        <svg
          className="pointer-events-none absolute inset-1 text-black/80"
          viewBox="0 0 36 36"
        >
          <circle
            className="text-black/40"
            stroke="currentColor"
            strokeWidth="3"
            fill="transparent"
            cx="18"
            cy="18"
            r="15.5"
          />
          <circle
            className="text-yellow-300"
            stroke="currentColor"
            strokeWidth="3.5"
            fill="transparent"
            strokeLinecap="round"
            strokeDasharray={2 * Math.PI * 15.5}
            strokeDashoffset={2 * Math.PI * 15.5 * (1 - progress)}
            cx="18"
            cy="18"
            r="15.5"
          />
        </svg>
      )}
      {isOnCooldown && (
        <div className="relative flex flex-col items-center justify-center gap-0.5 drop-shadow-[0_1px_2px_rgba(0,0,0,0.9)]">
          <span className={`font-semibold ${textSize}`}>
            {remainingSeconds}
          </span>
        </div>
      )}
      {isOnCooldown && <div className="absolute inset-0 bg-black/60" />}
      {isOnCooldown && (
        <div className="absolute bottom-0 left-0 right-0 h-1.5 bg-yellow-400/80" />
      )}
      {!isOnCooldown && (
        <div className="absolute bottom-0 left-0 right-0 h-1 bg-emerald-400/70" />
      )}
    </button>
  );
}

type UltButtonProps = {
  ultData: {
    remaining: number;
    elapsed: number;
    maxCd: number;
    rankCD: number;
    rankLabel: string;
    status: "down" | "maybe" | "up";
  } | null;
  ultImageUrl: string;
  ultCooldowns: number[];
  size: "large" | "small";
  onToggle: () => void;
};

function UltButton({
  ultData,
  ultImageUrl,
  ultCooldowns,
  size,
  onToggle,
}: UltButtonProps) {
  const dimension = size === "large" ? "w-20 h-20" : "w-16 h-16";
  const textSize = size === "large" ? "text-xl" : "text-sm";
  const [clickCount, setClickCount] = useState(0);
  const clickTimerRef = useState<NodeJS.Timeout | null>(null)[0];

  const isOnCooldown = !!ultData && ultData.remaining > 0;
  const progress =
    ultData && isOnCooldown
      ? Math.min(1, Math.max(0, ultData.remaining / ultData.rankCD))
      : 0;

  let borderColor = "border-slate-600";
  let barColor = "bg-emerald-400/70";
  let circleColor = "text-yellow-300";

  if (ultData) {
    if (ultData.status === "down") {
      borderColor = isOnCooldown ? "border-red-500" : "border-slate-600";
      barColor = "bg-red-400/80";
      circleColor = "text-red-300";
    } else if (ultData.status === "maybe") {
      borderColor = isOnCooldown ? "border-yellow-400" : "border-slate-600";
      barColor = "bg-yellow-400/80";
      circleColor = "text-yellow-300";
    } else {
      borderColor = isOnCooldown ? "border-emerald-400" : "border-slate-600";
      barColor = "bg-emerald-400/70";
      circleColor = "text-emerald-300";
    }
  }

  const handleClick = () => {
    setClickCount((prev) => prev + 1);

    if (clickTimerRef) {
      clearTimeout(clickTimerRef);
    }

    const timer = setTimeout(() => {
      if (clickCount + 1 === 1) {
        // Single click
        if (!isOnCooldown) {
          onToggle();
        }
      } else if (clickCount + 1 >= 2) {
        // Double click
        if (isOnCooldown) {
          onToggle();
        }
      }
      setClickCount(0);
    }, 250);

    // @ts-ignore
    clickTimerRef = timer;
  };

  return (
    <div className="flex flex-col items-center gap-1">
      <button
        type="button"
        onClick={handleClick}
        className={`relative ${dimension} rounded-md border ${borderColor} bg-slate-900 text-slate-100 shadow-sm transition-transform active:scale-95 flex items-center justify-center overflow-hidden`}
      >
        <img
          src={ultImageUrl}
          alt="Ult"
          className="absolute inset-0 h-full w-full object-cover"
        />
        <div
          className={`absolute inset-0 border-2 ${
            isOnCooldown ? `${borderColor}/80` : "border-slate-500/40"
          } rounded-md`}
        />
        {isOnCooldown && (
          <svg
            className="pointer-events-none absolute inset-1 text-black/80"
            viewBox="0 0 36 36"
          >
            <circle
              className="text-black/40"
              stroke="currentColor"
              strokeWidth="3"
              fill="transparent"
              cx="18"
              cy="18"
              r="15.5"
            />
            <circle
              className={circleColor}
              stroke="currentColor"
              strokeWidth="3.5"
              fill="transparent"
              strokeLinecap="round"
              strokeDasharray={2 * Math.PI * 15.5}
              strokeDashoffset={2 * Math.PI * 15.5 * (1 - progress)}
              cx="18"
              cy="18"
              r="15.5"
            />
          </svg>
        )}
        {isOnCooldown && (
          <div className="relative flex flex-col items-center justify-center gap-0.5 drop-shadow-[0_1px_2px_rgba(0,0,0,0.9)]">
            <span className={`font-semibold ${textSize}`}>
              {ultData?.remaining}
            </span>
          </div>
        )}
        {isOnCooldown && <div className="absolute inset-0 bg-black/60" />}
        {isOnCooldown && (
          <div
            className={`absolute bottom-0 left-0 right-0 h-1.5 ${barColor}`}
          />
        )}
        {!isOnCooldown && (
          <div className={`absolute bottom-0 left-0 right-0 h-1 ${barColor}`} />
        )}
      </button>
    </div>
  );
}

type RoleCardProps = {
  slot: RoleSlot;
  now: number;
  size: "large" | "small";
  onToggleSpell: (spellKey: "spell1" | "spell2") => void;
  onSelectHighlight?: () => void;
  isHighlighted?: boolean;
  champion?: ChampionSummary | null;
  onToggleUlt?: () => void;
};

function RoleCard({
  slot,
  now,
  size,
  onToggleSpell,
  onSelectHighlight,
  isHighlighted,
  champion,
  onToggleUlt,
}: RoleCardProps) {
  const ultData = useMemo(() => {
    if (
      !champion?.ultCooldowns ||
      champion.ultCooldowns.length === 0 ||
      !slot.ultLastClickTime
    ) {
      return null;
    }

    const ultCooldowns = champion.ultCooldowns;
    const maxCd = Math.max(...ultCooldowns);
    const elapsedMs = now - slot.ultLastClickTime;
    const elapsed = Math.max(0, Math.floor(elapsedMs / 1000));

    let rankCD: number;
    let rankLabel: string;
    let remaining: number;
    let status: "down" | "maybe" | "up";

    if (slot.ultRankMode === "manual" && slot.ultRankManual) {
      const idx = Math.min(slot.ultRankManual - 1, ultCooldowns.length - 1);
      rankCD = ultCooldowns[idx];
      rankLabel = `R${slot.ultRankManual}`;
      remaining = Math.max(0, Math.ceil(rankCD - elapsed));
      status = elapsed < rankCD ? "down" : "up";
    } else {
      remaining = Math.max(0, Math.ceil(maxCd - elapsed));
      const possibleRanks = ultCooldowns
        .map((cd, idx) => ({ cd, rank: idx + 1 }))
        .filter((r) => elapsed >= r.cd);
      if (possibleRanks.length > 0) {
        const best = possibleRanks[possibleRanks.length - 1];
        rankCD = best.cd;
        rankLabel = `R${best.rank}`;
      } else {
        rankCD = ultCooldowns[0];
        rankLabel = "R1";
      }

      if (elapsed < rankCD) {
        status = "down";
      } else if (elapsed >= maxCd) {
        status = "up";
      } else {
        status = "maybe";
      }
    }

    return { remaining, elapsed, maxCd, rankCD, rankLabel, status };
  }, [
    champion,
    slot.ultLastClickTime,
    slot.ultRankMode,
    slot.ultRankManual,
    now,
  ]);

  const isUltOnCooldown = !!ultData && ultData.remaining > 0;

  return (
    <div
      className={`flex flex-col gap-2 rounded-xl border ${
        isHighlighted
          ? "border-2 border-yellow-400/90 shadow-[0_0_25px_rgba(250,204,21,0.35)]"
          : "border-slate-600/80"
      } bg-slate-900/80 p-3 shadow-md`}
    >
      <button
        type="button"
        onClick={onSelectHighlight}
        className="flex items-center justify-between gap-2 text-left"
      >
        <div className="flex items-center gap-2">
          <div className="relative h-6 w-6 overflow-hidden rounded-full border border-slate-600 bg-slate-900">
            <Image
              src={ROLE_ICONS[slot.id]}
              alt={slot.label}
              fill
              sizes="24px"
              className="object-contain"
            />
          </div>
          {champion && (
            <div className="relative h-6 w-6 overflow-hidden rounded border border-slate-600 bg-slate-900">
              <img
                src={champion.imageUrl}
                alt={champion.name}
                className="h-full w-full object-cover"
              />
            </div>
          )}
        </div>
        <span className="text-[10px] uppercase tracking-wide text-slate-400">
          Focus
        </span>
      </button>
      <div className="flex items-center justify-around gap-3">
        <SpellButton
          state={slot.spell1}
          size={size}
          now={now}
          onToggle={() => onToggleSpell("spell1")}
        />
        <SpellButton
          state={slot.spell2}
          size={size}
          now={now}
          onToggle={() => onToggleSpell("spell2")}
        />
      </div>
      {champion &&
        champion.ultCooldowns &&
        champion.ultCooldowns.length > 0 &&
        onToggleUlt && (
          <div className="mt-2 flex items-center justify-center">
            <UltButton
              ultData={ultData}
              ultImageUrl={champion.ultImageUrl}
              ultCooldowns={champion.ultCooldowns}
              size={size}
              onToggle={onToggleUlt}
            />
          </div>
        )}
    </div>
  );
}

export default function Home() {
  const [slots, setSlots] = useState<RoleSlot[]>(() => INITIAL_SLOTS);
  const [activeRoleId, setActiveRoleId] = useState<RoleId>("mid");
  const [isConfigOpen, setIsConfigOpen] = useState(false);

  const isLandscape = useIsLandscape();
  const now = useNow(200);
  const { champions, loading: championsLoading } = useChampions();

  useEffect(() => {
    if (typeof window === "undefined") return;

    try {
      const raw = window.localStorage.getItem("spells-cd-slots-v1");
      if (!raw) return;
      const parsed = JSON.parse(raw) as RoleSlot[];
      if (!Array.isArray(parsed) || parsed.length === 0) return;
      setSlots(parsed);
    } catch {
      // ignore invalid storage
    }
  }, []);

  useEffect(() => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage.setItem("spells-cd-slots-v1", JSON.stringify(slots));
    } catch {
      // ignore
    }
  }, [slots]);

  const activeSlot = useMemo(
    () => slots.find((slot) => slot.id === activeRoleId) ?? slots[0],
    [slots, activeRoleId]
  );

  const secondarySlots = useMemo(
    () => slots.filter((slot) => slot.id !== activeSlot.id),
    [slots, activeSlot.id]
  );

  const handleToggleSpell = (roleId: RoleId, spellKey: "spell1" | "spell2") => {
    setSlots((prev) =>
      prev.map((slot) => {
        if (slot.id !== roleId) return slot;

        const currentState = slot[spellKey];
        const spell = SPELLS[currentState.spellId];

        const nowMs = Date.now();
        const isRunning =
          !!currentState.endTime && currentState.endTime > nowMs;

        const nextState: SpellState = {
          spellId: currentState.spellId,
          endTime: isRunning ? null : nowMs + spell.cooldown * 1000,
        };

        return {
          ...slot,
          [spellKey]: nextState,
        };
      })
    );
  };

  const handleToggleUlt = (roleId: RoleId) => {
    setSlots((prev) =>
      prev.map((slot) => {
        if (slot.id !== roleId) return slot;

        const champ = champions.find((c) => c.id === slot.championId);
        if (!champ || !champ.ultCooldowns || champ.ultCooldowns.length === 0) {
          return slot;
        }

        const nowMs = Date.now();

        // Verificar se está realmente em cooldown (não apenas se tem ultLastClickTime)
        let isRunning = false;
        if (slot.ultLastClickTime) {
          const elapsed = Math.floor((nowMs - slot.ultLastClickTime) / 1000);
          const maxCd = Math.max(...champ.ultCooldowns);

          if (slot.ultRankMode === "manual" && slot.ultRankManual) {
            const idx = Math.min(
              slot.ultRankManual - 1,
              champ.ultCooldowns.length - 1
            );
            const rankCD = champ.ultCooldowns[idx];
            isRunning = elapsed < rankCD;
          } else {
            isRunning = elapsed < maxCd;
          }
        }

        return {
          ...slot,
          ultLastClickTime: isRunning ? null : nowMs,
        };
      })
    );
  };

  const handleResetAll = () => {
    setSlots(INITIAL_SLOTS);
    setActiveRoleId("mid");
    if (typeof window !== "undefined") {
      try {
        window.localStorage.removeItem("spells-cd-slots-v1");
      } catch {
        // ignore
      }
    }
  };

  const portraitLayout = (
    <div className="flex w-full max-w-md flex-col gap-3">
      {slots.map((slot) => {
        const champ = champions.find((c) => c.id === slot.championId) ?? null;
        return (
          <RoleCard
            key={slot.id}
            slot={slot}
            now={now}
            size="large"
            onToggleSpell={(spellKey) => handleToggleSpell(slot.id, spellKey)}
            onSelectHighlight={() => setActiveRoleId(slot.id)}
            isHighlighted={slot.id === activeRoleId}
            champion={champ}
            onToggleUlt={
              champ && champ.ultCooldowns.length > 0
                ? () => handleToggleUlt(slot.id)
                : undefined
            }
          />
        );
      })}
    </div>
  );

  const landscapeLayout = (
    <div className="flex w-full max-w-4xl flex-col gap-4">
      <div className="flex flex-col items-center gap-2">
        <span className="text-[11px] uppercase tracking-wide text-slate-400">
          Slot em foco
        </span>
        <div className="flex justify-center">
          {(() => {
            const champ =
              champions.find((c) => c.id === activeSlot.championId) ?? null;
            return (
              <RoleCard
                slot={activeSlot}
                now={now}
                size="large"
                onToggleSpell={(spellKey) =>
                  handleToggleSpell(activeSlot.id, spellKey)
                }
                onSelectHighlight={undefined}
                isHighlighted
                champion={champ}
                onToggleUlt={
                  champ && champ.ultCooldowns.length > 0
                    ? () => handleToggleUlt(activeSlot.id)
                    : undefined
                }
              />
            );
          })()}
        </div>
      </div>
      <span className="mt-1 text-center text-[11px] uppercase tracking-wide text-slate-500">
        Outros oponentes
      </span>
      <div className="grid grid-cols-2 gap-3 md:grid-cols-4">
        {secondarySlots.map((slot) => {
          const champ = champions.find((c) => c.id === slot.championId) ?? null;
          return (
            <RoleCard
              key={slot.id}
              slot={slot}
              now={now}
              size="large"
              onToggleSpell={(spellKey) => handleToggleSpell(slot.id, spellKey)}
              onSelectHighlight={() => setActiveRoleId(slot.id)}
              isHighlighted={slot.id === activeRoleId}
              champion={champ}
              onToggleUlt={
                champ && champ.ultCooldowns.length > 0
                  ? () => handleToggleUlt(slot.id)
                  : undefined
              }
            />
          );
        })}
      </div>
    </div>
  );

  return (
    <div className="flex min-h-screen w-full items-center justify-center bg-slate-950 text-slate-100">
      <main className="relative flex h-full min-h-screen w-full max-w-5xl flex-col items-center gap-4 px-4 py-4">
        <button
          type="button"
          onClick={() => setIsConfigOpen(true)}
          className="absolute right-4 top-4 rounded-lg border border-slate-600 bg-slate-800 px-3 py-1.5 text-xs font-medium text-slate-100 shadow-sm hover:bg-slate-700"
        >
          Config
        </button>

        <section className="flex w-full flex-1 items-center justify-center pb-4">
          {isLandscape ? landscapeLayout : portraitLayout}
        </section>

        {isConfigOpen && (
          <div className="fixed inset-0 z-20 flex items-center justify-center bg-black/70">
            <div className="w-full max-w-3xl rounded-2xl border border-slate-700 bg-slate-900 p-5 shadow-2xl">
              <div className="mb-4 flex items-center justify-between gap-3">
                <div className="flex flex-col gap-1">
                  <h2 className="text-sm font-semibold uppercase tracking-wide text-slate-200">
                    Configuração de Spells
                  </h2>
                  <p className="text-[11px] text-slate-400">
                    Ajuste rapidamente as spells dos 5 oponentes. Os tempos de
                    cooldown usam os valores padrão de cada spell.
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <button
                    type="button"
                    onClick={handleResetAll}
                    className="rounded-md px-2 py-1 text-[10px] text-red-300 hover:bg-red-900/40"
                  >
                    Limpar tudo
                  </button>
                  <button
                    type="button"
                    onClick={() => setIsConfigOpen(false)}
                    className="rounded-md px-2 py-1 text-xs text-slate-300 hover:bg-slate-800"
                  >
                    Fechar
                  </button>
                </div>
              </div>

              <div className="max-h-[70vh] overflow-y-auto pr-1 text-xs">
                <div className="grid gap-3 md:grid-cols-2">
                  {[...slots]
                    .sort((a, b) =>
                      a.id === activeRoleId ? -1 : b.id === activeRoleId ? 1 : 0
                    )
                    .map((slot) => {
                      const isActive = slot.id === activeRoleId;
                      return (
                        <div
                          key={slot.id}
                          className={`flex flex-col gap-2 rounded-lg border p-3 ${
                            isActive
                              ? "md:col-span-2 border-yellow-400/80 bg-slate-900 shadow-[0_0_18px_rgba(250,204,21,0.35)]"
                              : "border-slate-700 bg-slate-950/60"
                          }`}
                        >
                          <div className="flex items-center justify-between gap-2">
                            <div className="flex items-center gap-2">
                              <div className="relative h-6 w-6 overflow-hidden rounded-full border border-slate-600 bg-slate-900">
                                <Image
                                  src={ROLE_ICONS[slot.id]}
                                  alt={slot.label}
                                  fill
                                  sizes="24px"
                                  className="object-contain"
                                />
                              </div>
                              <span className="text-[11px] font-semibold uppercase tracking-wide text-slate-200">
                                {slot.label}
                              </span>
                            </div>
                            <button
                              type="button"
                              onClick={() => setActiveRoleId(slot.id)}
                              className={`rounded-full px-2 py-0.5 text-[10px] font-medium uppercase tracking-wide ${
                                isActive
                                  ? "bg-yellow-400 text-black"
                                  : "border border-slate-600 bg-slate-900 text-slate-300 hover:border-yellow-400/70 hover:text-yellow-300"
                              }`}
                            >
                              {isActive ? "Destaque" : "Focar"}
                            </button>
                          </div>

                          <div className="mt-1 flex flex-col gap-2">
                            <div className="flex items-center gap-2">
                              <span className="text-[10px] uppercase tracking-wide text-slate-400">
                                Champion
                              </span>
                              <ChampionPicker
                                champions={champions}
                                value={slot.championId ?? null}
                                onChange={(id) => {
                                  setSlots((prev) =>
                                    prev.map((s) =>
                                      s.id === slot.id
                                        ? {
                                            ...s,
                                            championId: id,
                                          }
                                        : s
                                    )
                                  );
                                }}
                                roleLabel={slot.label}
                              />
                            </div>

                            {(() => {
                              const champ = champions.find(
                                (c) => c.id === slot.championId
                              );
                              if (!champ) return null;

                              const cds = champ.ultCooldowns;
                              const cdsLabel =
                                cds && cds.length > 0
                                  ? cds.join(" / ") + "s"
                                  : "-";

                              const mode = slot.ultRankMode ?? "auto";
                              const manualRank = slot.ultRankManual ?? 1;

                              return (
                                <div className="flex flex-col gap-1 text-[10px] text-slate-400">
                                  <div className="flex items-center gap-2">
                                    <span className="truncate max-w-[160px]">
                                      R: {champ.ultName}
                                    </span>
                                    <span className="text-slate-500">•</span>
                                    <span>{cdsLabel}</span>
                                  </div>
                                  {cds && cds.length > 0 && (
                                    <div className="flex items-center gap-1">
                                      <span className="uppercase tracking-wide text-slate-500">
                                        Modo
                                      </span>
                                      <div className="flex gap-1">
                                        <button
                                          type="button"
                                          onClick={() =>
                                            setSlots((prev) =>
                                              prev.map((s) =>
                                                s.id === slot.id
                                                  ? {
                                                      ...s,
                                                      ultRankMode: "auto",
                                                      ultLastClickTime: null,
                                                    }
                                                  : s
                                              )
                                            )
                                          }
                                          className={`rounded px-2 py-0.5 text-[10px] ${
                                            mode === "auto"
                                              ? "bg-yellow-400 text-black"
                                              : "border border-slate-600 bg-slate-900 text-slate-200 hover:border-yellow-400/70 hover:text-yellow-300"
                                          }`}
                                        >
                                          Auto
                                        </button>
                                        {cds.map((_, idx) => {
                                          const lvl = idx + 1;
                                          const active =
                                            mode === "manual" &&
                                            manualRank === lvl;
                                          return (
                                            <button
                                              key={lvl}
                                              type="button"
                                              onClick={() =>
                                                setSlots((prev) =>
                                                  prev.map((s) =>
                                                    s.id === slot.id
                                                      ? {
                                                          ...s,
                                                          ultRankMode: "manual",
                                                          ultRankManual: lvl,
                                                          ultLastClickTime:
                                                            null,
                                                        }
                                                      : s
                                                  )
                                                )
                                              }
                                              className={`rounded px-2 py-0.5 text-[10px] ${
                                                active
                                                  ? "bg-yellow-400 text-black"
                                                  : "border border-slate-600 bg-slate-900 text-slate-200 hover:border-yellow-400/70 hover:text-yellow-300"
                                              }`}
                                            >
                                              R{lvl}
                                            </button>
                                          );
                                        })}
                                      </div>
                                    </div>
                                  )}
                                </div>
                              );
                            })()}
                          </div>

                          <div className="grid grid-cols-1 gap-2 sm:grid-cols-2">
                            <div className="flex flex-col gap-1">
                              <span className="text-[10px] uppercase tracking-wide text-slate-400">
                                Spell 1
                              </span>
                              <select
                                className="h-8 rounded-md border border-slate-700 bg-slate-900 px-2 text-[11px] text-slate-100 focus:outline-none focus:ring-1 focus:ring-yellow-400"
                                value={slot.spell1.spellId}
                                onChange={(e) => {
                                  const value = e.target.value as SpellId;
                                  setSlots((prev) =>
                                    prev.map((s) => {
                                      if (s.id !== slot.id) return s;
                                      return {
                                        ...s,
                                        spell1: {
                                          spellId: value,
                                          endTime: null,
                                        },
                                      };
                                    })
                                  );
                                }}
                              >
                                {Object.values(SPELLS).map((spell) => (
                                  <option key={spell.id} value={spell.id}>
                                    {spell.name} ({spell.cooldown}s)
                                  </option>
                                ))}
                              </select>
                            </div>
                            <div className="flex flex-col gap-1">
                              <span className="text-[10px] uppercase tracking-wide text-slate-400">
                                Spell 2
                              </span>
                              <select
                                className="h-8 rounded-md border border-slate-700 bg-slate-900 px-2 text-[11px] text-slate-100 focus:outline-none focus:ring-1 focus:ring-yellow-400"
                                value={slot.spell2.spellId}
                                onChange={(e) => {
                                  const value = e.target.value as SpellId;
                                  setSlots((prev) =>
                                    prev.map((s) => {
                                      if (s.id !== slot.id) return s;
                                      return {
                                        ...s,
                                        spell2: {
                                          spellId: value,
                                          endTime: null,
                                        },
                                      };
                                    })
                                  );
                                }}
                              >
                                {Object.values(SPELLS).map((spell) => (
                                  <option key={spell.id} value={spell.id}>
                                    {spell.name} ({spell.cooldown}s)
                                  </option>
                                ))}
                              </select>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                </div>
              </div>
            </div>
          </div>
        )}
      </main>
    </div>
  );
}
